% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uwot.R
\name{lvish}
\alias{lvish}
\title{Dimensionality Reduction with a LargeVis-like method}
\usage{
lvish(X, perplexity = 50, n_neighbors = perplexity * 3,
  n_components = 2, metric = "euclidean", n_epochs = -1, alpha = 1,
  scale = "maxabs", init = "lvrandom", gamma = 7,
  negative_sample_rate = 5, nn_method = NULL, n_trees = 50,
  search_k = 2 * n_neighbors * n_trees, n_threads = max(1,
  RcppParallel::defaultNumThreads()/2), grain_size = 1,
  kernel = "gauss", ret_nn = FALSE, verbose = getOption("verbose",
  TRUE))
}
\arguments{
\item{X}{Input data. Can be a \code{\link{data.frame}}, \code{\link{matrix}},
\code{\link[stats]{dist}} object or \code{\link[Matrix]{sparseMatrix}}. A
sparse matrix is interpreted as a distance matrix and both implicit and
explicit zero entries are ignored. Set zero distances you want to keep to
an arbitrarily small non-zero value (e.g. \code{1e-10}). Matrix and data
frames should contain one observation per row. Data frames will have any
non-numeric columns removed, although factor columns will be used if
explicitly included via \code{metric} (see the help for \code{metric} for
details). Can be \code{NULL} if precomputed nearest neighbor data is passed
to \code{nn_method}, and \code{init} is not \code{"spca"} or \code{"pca"}.}

\item{perplexity}{Controls the size of the local neighborhood used for
manifold approximation. This is the analogous to \code{n_neighbors} in
\code{\link{umap}}. Change this, rather than \code{n_neighbors}.}

\item{n_neighbors}{The number of neighbors to use when calculating the
\code{perplexity}. Usually set to three times the value of the
\code{perplexity}. Must be at least as large as \code{perplexity}.}

\item{n_components}{The dimension of the space to embed into. This defaults
to \code{2} to provide easy visualization, but can reasonably be set to any
integer value in the range \code{2} to \code{100}.}

\item{metric}{Type of distance metric to use to find nearest neighbors. One
  of:
\itemize{
  \item \code{"euclidean"} (the default)
  \item \code{"cosine"}
  \item \code{"manhattan"}
  \item \code{"hamming"}
  \item \code{"categorical"} (see below)
}
Only applies if \code{nn_method = "annoy"} (for \code{nn_method = "fnn"}, the
distance metric is always "euclidean"). If \code{X} is a data frame or matrix, 
then multiple metrics can be specified, by passing a list to this argument,
where the name of each item in the list is one of the metric names above. 
The value of each list item should be a vector giving the names or integer 
ids of the columns to be included in a calculation. Each metric calculation
results in a separate fuzzy simplicial set, which are intersected together
to produce the final set. Metric names can be repeated. Because non-numeric
columns are removed from the data frame, it is safer to use column names than
integer ids. Factor columns can also be used by specifying the metric name
\code{"categorical"}. Factor columns are treated different from numeric 
columns and although multiple factor columns can be specified in
a vector, each factor column specified is processed individually.}

\item{n_epochs}{Number of epochs to use during the optimization of the
embedded coordinates. The default is calculate the number of epochs
dynamically based on dataset size, to give the same number of edge samples
as the LargeVis defaults. This is usually substantially larger than the
UMAP defaults.}

\item{alpha}{Initial learning rate used in optimization of the coordinates.}

\item{scale}{Scaling to apply to \code{X} if it is a data frame or matrix:
\itemize{
  \item{\code{"none"} or \code{FALSE} or \code{NULL}} No scaling.
  \item{\code{"Z"} or \code{"scale"} or \code{TRUE}} Scale each column to
  zero mean and variance 1.
  \item{\code{"maxabs"}} Center each column to mean 0, then divide each
  element by the maximum absolute value over the entire matrix.
  \item{\code{"range"}} Range scale the entire matrix, so the smallest
  element is 0 and the largest is 1.
  \item{\code{"colrange"}} Scale each column in the range (0,1).
}
For lvish, the default is \code{"maxabs"}, for consistency with LargeVis.}

\item{init}{Type of initialization for the coordinates. Options are:
\itemize{
  \item \code{"spectral"} Spectral embedding using the normalized Laplacian
  of the fuzzy 1-skeleton, with Gaussian noise added.
  \item \code{"normlaplacian"}. Spectral embedding using the normalized
  Laplacian of the fuzzy 1-skeleton, without noise.
  \item \code{"random"}. Coordinates assigned using a uniform random
  distribution between -10 and 10.
  \item \code{"lvrandom"}. Coordinates assigned using a Gaussian
  distribution with standard deviation 1e-4, as used in LargeVis
  (Tang et al., 2016) and t-SNE.
  \item \code{"laplacian"}. Spectral embedding using the Laplacian Eigenmap
  (Belkin and Niyogi, 2002).
  \item \code{"pca"}. The first two principal components from PCA of
  \code{X} if \code{X} is a data frame, and from a 2-dimensional classical
  MDS if \code{X} is of class \code{"dist"}.
  \item \code{"spca"}. Like \code{"pca"}, but each dimension is then scaled
  so the standard deviation is 1e-4, to give a distribution similar to
  that used in t-SNE and LargeVis.
  \item A matrix of initial coordinates.
}}

\item{gamma}{Weighting applied to negative samples in low dimensional embedding
optimization. Values higher than one will result in greater weight
being given to negative samples.}

\item{negative_sample_rate}{The number of negative edge/1-simplex samples to
use per positive edge/1-simplex sample in optimizing the low dimensional
embedding.}

\item{nn_method}{Method for finding nearest neighbors. Options are:
\itemize{
  \item \code{"fnn"}. Use exact nearest neighbors via the
    \href{https://cran.r-project.org/package=FNN}{FNN} package.
  \item \code{"annoy"} Use approximate nearest neighbors via the
    \href{https://cran.r-project.org/package=RcppAnnoy}{RcppAnnoy} package.
 }
By default, if \code{X} has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass precalculated nearest neighbor data to this argument. It
must be a list consisting of two elements:
\itemize{
  \item \code{"idx"}. A \code{n_vertices x n_neighbors} matrix
  containing the integer indexes of the nearest neighbors in \code{X}. Each
  vertex is considered to be its own nearest neighbor, i.e.
  \code{idx[, 1] == 1:n_vertices}.
  \item \code{"dist"}. A \code{n_vertices x n_neighbors} matrix
  containing the distances of the nearest neighbors.
}
Multiple nearest neighbor data (e.g. from two different precalulated 
metrics) can be passed by passing a list containing the nearest neighbor
data lists as items. 
The \code{n_neighbors} parameter is ignored when using precalculated
nearest neighbor data.}

\item{n_trees}{Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With \code{search_k}, determines the accuracy of the
Annoy nearest neighbor search. Only used if the \code{nn_method} is
\code{"annoy"}. Sensible values are between \code{10} to \code{100}.}

\item{search_k}{Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With \code{n_trees}, determines the accuracy of the Annoy nearest neighbor
search. Only used if the \code{nn_method} is \code{"annoy"}.}

\item{n_threads}{Number of threads to use. Default is half that recommended
by RcppParallel. For nearest neighbor search, only applies if
\code{nn_method = "annoy"}.}

\item{grain_size}{Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Used in conjunction with \code{n_threads}.}

\item{kernel}{Type of kernel function to create input probabilities. Can be
one of \code{"gauss"} (the default) or \code{"knn"}. \code{"gauss"} uses
the usual Gaussian weighted similarities. \code{"knn"} assigns equal
probabilities to every edge in the nearest neighbor graph, and zero
otherwise, using \code{perplexity} nearest neighbors. The \code{n_neighbors}
parameter is ignored in this case.}

\item{ret_nn}{If \code{TRUE}, then in addition to the embedding, also return
nearest neighbor data that can be used as input to \code{nn_method} to
avoid the overhead of repeatedly calculating the nearest neighbors when
manipulating unrelated parameters (e.g. \code{min_dist}, \code{n_epochs},
\code{init}). See the "Value" section for the names of the list items. If
\code{FALSE}, just return the coordinates. Note that the nearest neighbors
could be sensitive to data scaling, so be wary of reusing nearest neighbor
data if modifying the \code{scale} parameter.}

\item{verbose}{If \code{TRUE}, log details to the console.}
}
\value{
A matrix of optimized coordinates, or if \code{ret_nn = TRUE},
  returns the nearest neigbor data as a list containing a matrix \code{idx}
  with the integer ids of the neighbors; and a matrix \code{dist} with the
  distances. This list can be used as input to the \code{nn_method}
  parameter.
}
\description{
Carry out dimensionality reduction of a dataset using a method similar to
LargeVis (Tang et al., 2016).
}
\details{
\code{lvish} differs from the official LargeVis implementation in the
following:

\itemize{
  \item Only the nearest-neighbor index search phase is multi-threaded.
  \item Matrix input data is not normalized.
  \item The \code{n_trees} parameter cannot be dynamically chosen based on
  data set size.
  \item Nearest neighbor results are not refined via the
  neighbor-of-my-neighbor method. The \code{search_k} parameter is twice
  as large than default to compensate.
  \item Gradient values are clipped to \code{4.0} rather than \code{5.0}.
  \item Negative edges are generated by uniform sampling of vertexes rather
  than their degree ^ 0.75.
  \item The default number of samples is much reduced. The default number of
  epochs, \code{n_epochs}, is set to \code{5000}, much larger than for
  \code{\link{umap}}, but may need to be increased further depending on your
  dataset. Using \code{init = "spectral"} can help.
}
}
\examples{
\dontrun{
# Use perplexity rather than n_neighbors to control the size of the local
neighborhood iris_lvish <- umap(iris, perplexity = 50, alpha = 0.5,
                                init = "random")

# Default number of epochs is much larger than for UMAP, assumes random
# initialization
# If using a more global initialization, can use fewer epochs
iris_lvish_short <- umap(iris, perpelxity = 50, n_epochs = 1000)
}
}
\references{
Tang, J., Liu, J., Zhang, M., & Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In \emph{Proceedings of the 25th International Conference on World Wide Web}
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
\url{https://arxiv.org/abs/1602.00370}
}
